Slides: <https://static.frontendmasters.com/resources/2024-04-10-product-design-fundamentals/product-design-fundamentals.pdf>

## Fundamentals

Informational (news), Task Oriented (apps), and Hybrid (both: e-commerce/social)

Unique challenges
- Repetition: minor friction can become irritating
- Complexity: lots of functionality
- Procedural knowledge: making changes breaks existing habits (backwards compatibility)

Why it matters?
- Acquire customers
- Retain customers
- Save money (by improving productivity)

### Core Principles (of Product Design)

Market awareness
- Competitors: what do they do good, bad, price?
- Market trends: user expectations?
- Positioning: how your product differs and compares?

User centric
- Goal: how does it help and how hard would it to be to do otherwise?
- Pain point: what problem / pain point does it solve?
- Need: is there a legit need for product or functionality?

User group awareness e.g. power users vs new users

Task orientated
- What tasks will users need to do? (Depends on: User group)
- Not all tasks are equal, which are more crucial for success?
- Which tasks are most frequent? (Guessing also care about recency too)

How feasible and scalable is the tech?

Simplicity
- Remove: can this element be removed?
- Hide: can this element be hidden (deep in app or within another element)?
- Shrink: visually deemphasis the element

Usability
- Easy to learn? Quick to do common tasks? Forgiving of mistakes?

Accessibility (a11y)
- User a11y: meet needs of the user
  - situational, temporary, permanent
  - holding toddler, broken arm, amputated arm
- Device a11y: screen size, etc

Brand identity
- Consistency
- Recognition & recall
- Emotional connection

### Start with Minimum Viable Product (MVP)

> PB's definition: product version w/ enough features to _attract_ early adopters
> and _validate_ product idea early in the dev cycle, gathering user _feedback_ for
> future iterations & improvements.

Why MVP?
- Reduce risk: validate concepts which lowers large-scale failure risk
- Speed to market: quicker launch, competitive edge
- Focus on core: concentrate on essential features
- Attract investors: tangible product & user data
- Learn: practical experience on market, users, and product
- Targeted resourcing: where to allocate resources (dev, marketing, scaling)

MVP loop
1. **Build**: simplest version, as cheaply as possible
1. **Listen**: to feedback and improve over time
1. **Adapt**: as required to attract new ~~customers~~ visitors
1. **Observe**: ~~customer~~ visitor behavior and adjust to fit user needs

More features is not better. For an MVP, just build one feature and do it well.

Identifying your MVP
- User needs: absolute core task(s) to achieve their goal?
- Value prop: what makes your product diff from the competition?
- Time & effort: which features can be built relatively easily?

Trialing your prototype
- Prototype testing: usability testing w/ small numbers
- Soft launch: small group of early adopters & gather feedback
- Monitor post launch: heat maps, session recordings, and analytics

Gathering (MVP) feedback
- Listen: social media, reviews, inbound messages
- Watch: session recorder
- Ask: surveys, interviews, feature suggestion

Iterating (on your MVP)
1. Discovery
1. Prototype
1. Test
1. Iterate
1. Launch (MVP)
1. Monitor
1. Refine
1. Implement
1. Launch (... and repeat)

Iterate on
- Initial MVP
- Future features

Building backlogs
- Optimization
- Innovation

Need a "pointing system", which uses the same criteria as "Identifying your MVP"

Common mistakes
- Rushed discovery: pressure to deliver too high & jump straight into prototyping
- No iterating post-launch: after a feature lands, no one checks
- No holistic thinking: no consideration to the overall experience

Establish future vision e.g. _Maximum_ Viable Product

Why create future vision?
- Design consistency: design system, language, and patterns
- Future planning: pave the foundation for upcoming features
- A goal: shared vision

Future vision is _not_ a straight jacket: still need to adapt.

Creating your vision
1. Research
1. Brainstorm
1. Prototype
1. Test
1. Backlog
1. Share

In conclusion:
- Start w/ an MVP and continually iterate
- Create a vision to work towards
- Product design != web design

## Top Tasks & Use Cases

Need to identify and understand your audience.

Why segment your audience?
- Different questions
- Different tasks
- Different needs

Use cases >>> demographics

Empathy map
- Questions & tasks
- Pain points
- Goals
- Journey
- Influences
- Feeling

Identify and understand use cases.

Gather potential tasks
- Customer feedback
- Site behavior
- Stakeholder interviews
- Search analysis
- Competitive analysis
- Social media
- Cheat with GPT

User stories: "As a _, I want to _, so that I can _ and I know when I am done _"

Identifying and understanding user top tasks.

Top task "lite" use PollUnit or similar:
1. New poll
1. "Collect ideas"
1. Instructions to search & like or create

Post-survey:
- De-dupe
- Simplify wording

TIL: "Kano survey" (might yield features users didn't know they wanted)

Organizing around top tasks.

PB's recommendation is UXMetrics.

- Open card sorting (open ended categories)
- Closed card sorting (pre-defined categories + a "I'm not sure")
- Tree testing

Top-level sections
- Fewer options better: four items in short-term memory
- Group options: if need > 4, group similar
- Keep labels short
- Avoid ambiguous
- Make options distinct
- Multiple clicks are OK

Test low agreement, not sures, and top tasks in subsections

In conclusion:
- Identity top tasks & organize w/ open card sorting
- Check tiny tasks are supported w/ closed card sorting
- Tree testing to confirm that info arch is working

## Prototyping (in Figma)

Explore ideas at a fraction of the cost of building them.

Frontend Masters has a course on Figma: <https://frontendmasters.com/courses/figma/>

Why prototype?
- You can (user) test
- Reduce risk
- Communication

Different types of prototypes
- Low-fi: paper, gray-scale
- High-fi: clickable, interactive

Plan the user flow
- Entry points
- Key actions & steps
- Decision points
- Error handling & feedback
- Alternative paths (shortcuts or varied paths)

Determine what fidelity
- **Ideation**: paper
- **Convergence**: gray-scale
- **Iteration**: clickable
- **Solution**: interactive

Engaging w/ stakeholders (using prototypes)
- Better product: more perspective
- Faster approval: unlikely to reject own work
- More support: defend it to others

Wireframing workshops
- Core journey: screens & functionality essential to the UX
- Controversial screens
- High effort screens

Crazy Eights
- Each team has 8 min to generate 8 ideas on 1 paper
- Pick the best four
- Two teams merge (two 4 becomes 8)
- Repeat until four ideas remaining

Design sprints (1 week e.g. 5 days)
1. Understand: make a map & choose a target
1. Diverge: sketch solutions
1. Converge: decide on best idea
1. Build: a prototype
1. Test: with target customers

PB doesn't like these:
- Hard to arrange: getting all stakeholders in a room for a week is hard
- Exhausting: highly intense
- Rushed: don't leave time to truly consider

Why "Paper" prototype?
- Low barrier: no special skills needed
- Everyone can participate: it's inclusive
- Fast
- Disposable
- Cost-effective

Why "Gray-scale" prototype?
- Fast to create
- Focuses on functionality (not caught up in aesthetics)
- Ideal for early testing

Tools: Balsamiq, Whimsical

Why "Clickable" prototype?
- Aesthetic
- Navigation testing
- Hierarchy testing

Tools: Lyssna, Maze

Why "Interactive" prototype?
- Realistic experience
- Act as a spec (for devs)
- Great sales tool

Tools: Justinmind

### Interface Design Fundamentals

Three steps to simplicity (same as before): "Can I _ it"
- Remove
- Hide
- Shrink

Limit options:
- 4 items in short-term memory
- Focus on top tasks

"Micro-copy technique" e.g. single-word

Chunking: if cannot reduce number of options, put them in groups

Progressive disclosure: break complex ops into series of smaller steps

Good defaults: on avg only 5% of users will change from defaults

Prioritize critical content: draw users to most important elements, not secondary info

Tool: Attention Insight ("spellchecker for designers")

### Building Dev-Ready Prototypes

Always use AutoLayout (mirrors CSS box model)

Don't forget states (hover, active, etc)

Include animation, if possible

Add annotation (comments)

Tip from the audience: HSL(A) for colors

In conclusion:
- Prototypes are powerful (wowowow)
- Needs careful planning & consideration

## Testing (the Prototype)

Why testing?
- Better product
- Resolve arguments
- Save $$$

Test lightweight but often

"The further you get in the dev cycle the higher the cost becomes"

From low to high cost
- Design
  - Wireframes
  - Mockups
  - Prototypes
- Build
  - Navigation
  - Functionality
- Post launch
  - Exit points (where people leave)
  - Friction points (where people get frustrated)
  - New functionality

Be pragmatic (about testing): testing _something_ is better than testing _nothing_\*

\* as long as you are aware of your biases

Recruitment
- Usability doesn't need exact audience (friends & family are good for this)
- Don't test with anyone related to organization or project
- Many testing tools with recruit on your behalf

Testing initial wireframes
- Don't test without basic content and navigation

Testing navigation: first-click test

Testing focus & impressions: 5-second test (PB does 8 seconds :^])

What are you looking for?
- Did they get it? Understanding the interface
- Did they see it? Top tasks

Testing mockups: static screens
- Break deadlock with stakeholders

Agree on brand keywords: stakeholders should agree early on

Tool: Brand Deck

Options:
- Semantic differential survey
- Comparison (vs competitors)

Testing prototypes & beta build
- Un-facilitated testing
- Want recordings? Tool: Lookback

Tips for facilitated usability testing
- Clearly define objectives
- Realistic tasks
- Prepare a script (but be flexible)
- Work hard to _relax_ people
- Encourage thinking aloud
- Remain neutral (don't lead or introduce bias)
- Answer questions at the end
- Show gratitude
- Debrief quickly

Which to pick?

Un-facilitated is easier to run, more numbers, more natural behavior, faster results ...

"is it working" testing

Facilitated is more adaptable, guided, more clarification, obverse non-verbal cues ...

"why isn't this working" testing

Testing live apps:
- PB highly recommends Microsoft Clarity
- Pay attention to exits, misclicks, rage clicks, excessive scrolling, and quick backs
- Additional clarification with heat maps and session recordings
- Testing smol solutions: A/B testing
- Testing big solutions: build & test prototype

In conclusion:
- Testing is _essential_ (to product design)
- Do it often & early
- Can be carried out through the dev cycle

## Design Systems (in Figma)

What and why?

Set of guidelines, standards, and components what unity design + dev efforts
across an org. A sort of blueprint for dev + design collab.

Why create one?
- Consistency: uniformity enhances UX and brand identity
- Efficiency & speed: reusable components yield faster dev & iterations
- Collaboration: improve teamwork
- Quality: has been designed once, properly
- Cost reduction: reduced rework and duplication effort

Basic building blocks
- **Styles**: typography, colors, layout etc
- **Elements**: buttons, forms, etc
- **Components**: menus, carousels, etc

Planning
- Avoid buying
  - Over-engineered
  - Long time to learn
  - Need to be customized
  - Bloated code
  - **Caveat**: buy to speed up creation of your own
- Get buy-in upfront
  - Collaborate: designers, devs, PMs, and other stakeholders
  - Sell the idea: get exec and team buy-in
- Reluctant management
  - Go stealth!
- Agree on objectives
  - Purpose: define goals
  - Scope: determine scale
  - Goal: what is success?
- Ask questions upfront
  - Accessibility (a11y): color contrast, keyboard nav, and screen reader support
  - Versioning: updates & changes
  - Responsiveness: across screen sizes & devices
  - Dark Mode
- Auditing an existing app
  - Existing assets
  - Gaps & inconsistencies
- Build as you go (for a new service)
  - Context: building components in isolation is hard
  - Focused: only building components you need
  - Faster & cheaper

Creating
- Start w/ styles
  - Layout grid
  - Layout padding
  - Typography (headings, weighting, additional styles e.g. underline, strikethrough, smallcaps)
  - Colors (variables vs styles [PB uses both] also dark modes)
  - Aesthetics
- Create basic elements
  - Don't forget states (hover, active, selected, expanded)
- Build out components
  - Avoid too much abstraction
  - Components usage
  - Step back (use components together to check holistically)

Implementing and evolving over time
- Turn components into code (Tool: ZeroHeight, Storybook)
- Design systems are never done
  - User feedback
  - Brand evolution
  - New features
- Process for adding new components
  1. **Research**: can we use existing? revise an existing? similar component?
  1. **Design, iterate, and test**
  1. **Dev & document**
  1. **Review & approve**
- Managing version control
  - Clear versioning strategy
  - Document changes
  - Rollout strategy
  - Deprecation strategy
  - Access to prev versions?
- Adoption and communication
  - Communicate value
  - Ownership, influence & improvement
  - Champions
  - Training & support

Leveling up your design system
- Design principles
  - Consistent design making
  - Focus on overall objectives
  - User-centric approach
  - "Big ol' hammer to hit stakeholders with when they do something stupid"
- Digital/design playbook
  - Agreed set of processes
  - Shared repo of knowledge
  - Improve collab & empowerment
- Content style guide
  - Consistency, quality, efficiency

In conclusion:
- Design system is invaluable _if it's planned carefully_
- Start with styles, then elements, finally components
- Consider rollout
